# Глава 3: Драйверы баз данных

Добро пожаловать снова, искатели приключений `reladiff`! В [Глава 2: Система конфигурации](02_configuration_system_.md) вы узнали, как сохранять и повторно использовать ваши "рецепты" сравнения `reladiff`, включая определение соединений с базами данных с помощью URI и имен, таких как `my_local_pg` или `my_snowflake`. Но как же `reladiff` на самом деле *общается* с этими разными базами данных? Вот тут и приходят на помощь **Драйверы баз данных**!

## Проблема: много языков, один инструмент

Представьте, что вы — путешественник по миру, и вам нужно общаться с людьми в разных странах. Некоторые говорят по-английски, некоторые — по-испански, другие — по-японски и так далее. Было бы невозможно выучить все языки, правда?

Базы данных похожи. PostgreSQL, MySQL, Snowflake, Oracle, BigQuery — все хранят данные, но "говорят" они немного на разных "языках". Это означает, что:
* у них могут быть разные способы **подключения**;
* их версия языка SQL (называемый "диалект") может иметь небольшие отличия;
* они могут представлять один и тот же тип данных (например, дату или число) немного по-разному внутри.

Если бы `reladiff` пришлось учить каждый из этих "языков" баз данных напрямую, получилась бы очень сложная и громоздкая программа!

## Решение: драйверы баз данных — ваши специализированные переводчики

Здесь на сцену выходят **Драйверы баз данных**!

Драйвер базы данных — это **специализированный переводчик** для конкретного "языка" базы данных.
* Хотите пообщаться с PostgreSQL? Используйте драйвер PostgreSQL.
* Нужно подключиться к Snowflake? Используйте драйвер Snowflake.

Каждый драйвер знает уникальные правила для подключения, отправки SQL-запросов и понимания типов данных именно для своей базы.

`reladiff` не нужно знать все тонкости PostgreSQL *и* MySQL *и* Snowflake. Вместо этого он просто использует правильный драйвер. А драйвер уже занимается всеми сложными переводами за сценой. Это позволяет `reladiff` сравнивать данные без проблем между более чем дюжиной систем баз данных, не вдаваясь в детали их внутренней работы.

Это очень мощно, потому что теперь вы можете сравнивать:
* таблицу в PostgreSQL с таблицей в Snowflake;
* данные из локальной базы MySQL с данными в облачной базе Redshift;
* любые комбинации из [поддерживаемых баз данных](docs/supported-databases.md)!

## Как вы взаимодействуете с драйверами

Как пользователь `reladiff`, вы в основном взаимодействуете с драйверами баз данных, даже не подозревая об этом! Когда вы указываете URI базы данных, `reladiff` автоматически определяет, какой драйвер использовать, исходя из начала URI (называемого "схемой").

Например:
* `postgresql://...` говорит `reladiff` использовать драйвер PostgreSQL.
* `snowflake://...` говорит использовать драйвер Snowflake.
* `mysql://...` — драйвер MySQL.

Также вы можете явно указать `reladiff`, какой драйвер использовать, в файле конфигурации `reladiff.toml`, о котором мы говорили в [Глава 2: Система конфигурации](02_configuration_system_.md).

Вот пример из нашего файла `reladiff.toml`:

```toml
# reladiff.toml

# Раздел для определения баз данных
[database.my_local_pg]
driver = "postgresql"  # <-- Здесь явно указываем использовать драйвер PostgreSQL
uri = "postgresql:///"

[database.my_snowflake]
driver = "snowflake"   # <-- Здесь явно указываем использовать драйвер Snowflake
uri = "snowflake://${SNOWFLAKE_USER}:${SNOWFLAKE_PASS}@..."
```

Даже если вы просто укажете `uri`, `reladiff` достаточно умен, чтобы определить драйвер по префиксу `postgresql://` или `snowflake://`. Поле `driver` нужно, если URI не совпадает идеально с известной схемой или чтобы быть максимально явным.

## Как `reladiff` подключается и переводит

Когда вы запускаете команду `reladiff`, происходит много процессов, чтобы обеспечить работу этих специальных переводчиков (драйверов).

Вот упрощенная последовательность событий:

```mermaid
sequenceDiagram
    actor Пользователь
    participant Reladiff["reladiff (основная программа)"]
    participant connect["функция connect()"]
    participant registry["Регистр драйверов"]
    participant pg_driver["Драйвер PostgreSQL"]
    participant pg_db["База данных PostgreSQL"]

    Пользователь->>Reladiff: Запускает 'reladiff postgresql:/// ...'
    Reladiff->>connect: "Привет, подключиться к 'postgresql:///'"
    connect->>registry: "Какой драйвер для URI 'postgresql'?"
    registry->>connect: "Используйте pg_driver!"
    connect->>pg_driver: "Создать соединение."
    pg_driver->>pg_db: Устанавливает соединение (по правилам PG)
    pg_db-->>pg_driver: Соединение готово!
    pg_driver-->>connect: Возвращает объект соединения
    connect-->>Reladiff: Возвращает готовое соединение к базе
    Note over Reladiff: Теперь `reladiff` может отправлять SQL-запросы через драйвер
    Reladiff->>pg_driver: "Выполнить SQL: SELECT * FROM events"
    pg_driver->>pg_db: Переводит и отправляет запрос (диалект PG)
    pg_db-->>pg_driver: Возвращает результаты (тип данных PG)
    pg_driver-->>Reladiff: Переводит результаты обратно (формат reladiff)
```

Как видите, функция `connect()` действует как центральный диспетчер, использующий "Регистр драйверов" — список всех доступных драйверов — для выбора нужного. После выбора драйвера он занимается всеми коммуникациями с конкретной базой.

### Как это реализовано в коде

`reladiff` не создает все драйверы с нуля. Он использует мощную библиотеку с открытым исходным кодом `Sqeleton` (произносится как "скелет"). `Sqeleton` предоставляет базовые блоки для подключения, запросов и понимания данных из множества баз данных.

`reladiff` расширяет возможности `Sqeleton` под свои нужды, например:
1. **MD5-хеширование:** важно для [Алгоритма HashDiff](05_hashdiff_algorithm_.md), чтобы быстро сравнивать строки.
2. **Нормализация значений:** обеспечивать одинаковое отображение данных (чисел, временных меток и т.д.) перед сравнением. Например, `DECIMAL(10,2)` в одной базе и `FLOAT` в другой могут немного по-разному хранить `12.34`, а normalization приводит их к единому виду.

Рассмотрим упрощенные примеры кода, чтобы понять, как это работает.

Во-первых, `reladiff/databases/__init__.py` импортирует все поддерживаемые драйверы:

```python
# Из reladiff/databases/__init__.py

# Импорт основных функций из Sqeleton
from sqeleton.databases import QueryError, ConnectError

# Импорт конкретных драйверов баз данных
from .postgresql import PostgreSQL
from .mysql import MySQL
from .snowflake import Snowflake
# ... еще много драйверов импортировано ...

from ._connect import connect  # Централизованная функция подключения
```

Этот файл просто собирает все компоненты драйверов для использования.

Далее, `reladiff/databases/_connect.py` содержит "Регистр драйверов", то есть словарь, который связывает схему URI (например, "postgresql") с классом базы данных:

```python
# Из reladiff/databases/_connect.py

import logging
from sqeleton.databases import Connect  # Базовая логика соединения Sqeleton

# Этот словарь — "Регистр драйверов"
DATABASE_BY_SCHEME = {
    "postgresql": PostgreSQL,
    "mysql": MySQL,
    "oracle": Oracle,
    "snowflake": Snowflake,
    # ... и так далее для всех поддерживаемых баз...
}

# Основная функция, которую использует reladiff для подключения
connect = Connect(DATABASE_BY_SCHEME)  # Sqeleton использует наш регистр
```

Когда `reladiff` вызывает `connect("postgresql:///...")`, этот объект ищет "postgresql" в `DATABASE_BY_SCHEME`, находит `PostgreSQL` и использует его класс для установки соединения.

Как `reladiff` расширяет драйверы `Sqeleton` для своих целей сравнения данных? Он использует специальный класс `ReladiffDialect`:

```python
# Из reladiff/databases/base.py

# Наследуемся от абстрактных миксинов Sqeleton
from sqeleton.abcs.mixins import AbstractMixin_MD5, AbstractMixin_NormalizeValue

class ReladiffDialect(AbstractMixin_MD5, AbstractMixin_NormalizeValue):
    """
    Этот класс добавляет специфичные для reladiff функции, такие как MD5-хеширование
    и нормализацию значений, к диалектам базы данных.
    """
    pass
```

Этот `ReladiffDialect` сам по себе ничего не делает, но служит базой, от которой наследуются все драйверы `reladiff`. Он гарантирует, что каждый драйвер реализует нужные методы для вычисления MD5 и нормализации значений.

В конце — отдельные драйверы для конкретных баз данных (например, для BigQuery или Vertica) объединяют ядро `Sqeleton` с расширениями `reladiff`:

```python
# Из reladiff/databases/bigquery.py (упрощенно)

from sqeleton.databases import bigquery  # ядро драйвера BigQuery
from .base import ReladiffDialect  # наши расширения для reladiff

# Диалект для BigQuery, с учетом требований reladiff
class Dialect(
    bigquery.Dialect,
    bigquery.Mixin_MD5,  # MD5 от Sqeleton для BigQuery
    bigquery.Mixin_NormalizeValue,  # нормализация значений
    ReladiffDialect  # наши расширения
):
    pass

# Сам класс базы данных BigQuery
class BigQuery(bigquery.BigQuery):
    dialect = Dialect()  # назначение объединенного диалекта
```

Это кажется сложным из-за наследования, но главная идея такова:
* `Sqeleton` обеспечивает основу для работы с базой (PostgreSQL, MySQL и т.п.).
* `reladiff` добавляет свои требования (через `ReladiffDialect`), чтобы каждая реализация драйвера могла выполнять задачи сравнения (хеширование, нормализация и т.п.).

Такая модульная структура делает `reladiff` очень гибким. Когда нужно добавить поддержку новой базы данных, разработчики могут использовать большую часть работы `Sqeleton` и лишь добавить специфичные для `reladiff` компоненты.

## Итоги

Теперь вы знаете о **Драйверах баз данных** — героях, которые позволяют `reladiff` общаться с множеством систем. Они выступают как специализированные переводчики, умеющие "говорить" на языке каждой базы. А `reladiff` использует библиотеки вроде `Sqeleton`, чтобы сделать это возможным.

Понимание драйверов помогает понять, почему `reladiff` поддерживает так много баз данных и как он сравнивает данные между ними последовательно.

В следующей главе мы рассмотрим концепцию [Табличного сегмента](04_table_segment_.md) — как `reladiff` представляет конкретные части таблиц, которые нужно сравнить, и как он подготавливает эти данные для эффективного сравнения.
